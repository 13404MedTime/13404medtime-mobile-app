// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'my_appointments_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$MyAppointmentsEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAppointments,
    required TResult Function(
            Function onSuccess, bool value, int index, BuildContext context)
        updateDrugStatus,
    required TResult Function(SwitchModel switchData) getInitialData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAppointments,
    TResult? Function(
            Function onSuccess, bool value, int index, BuildContext context)?
        updateDrugStatus,
    TResult? Function(SwitchModel switchData)? getInitialData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAppointments,
    TResult Function(
            Function onSuccess, bool value, int index, BuildContext context)?
        updateDrugStatus,
    TResult Function(SwitchModel switchData)? getInitialData,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAppointmentsEvent value) getAppointments,
    required TResult Function(UpdateDrugStatus value) updateDrugStatus,
    required TResult Function(GetInitialData value) getInitialData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAppointmentsEvent value)? getAppointments,
    TResult? Function(UpdateDrugStatus value)? updateDrugStatus,
    TResult? Function(GetInitialData value)? getInitialData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAppointmentsEvent value)? getAppointments,
    TResult Function(UpdateDrugStatus value)? updateDrugStatus,
    TResult Function(GetInitialData value)? getInitialData,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyAppointmentsEventCopyWith<$Res> {
  factory $MyAppointmentsEventCopyWith(
          MyAppointmentsEvent value, $Res Function(MyAppointmentsEvent) then) =
      _$MyAppointmentsEventCopyWithImpl<$Res, MyAppointmentsEvent>;
}

/// @nodoc
class _$MyAppointmentsEventCopyWithImpl<$Res, $Val extends MyAppointmentsEvent>
    implements $MyAppointmentsEventCopyWith<$Res> {
  _$MyAppointmentsEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GetAppointmentsEventImplCopyWith<$Res> {
  factory _$$GetAppointmentsEventImplCopyWith(_$GetAppointmentsEventImpl value,
          $Res Function(_$GetAppointmentsEventImpl) then) =
      __$$GetAppointmentsEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetAppointmentsEventImplCopyWithImpl<$Res>
    extends _$MyAppointmentsEventCopyWithImpl<$Res, _$GetAppointmentsEventImpl>
    implements _$$GetAppointmentsEventImplCopyWith<$Res> {
  __$$GetAppointmentsEventImplCopyWithImpl(_$GetAppointmentsEventImpl _value,
      $Res Function(_$GetAppointmentsEventImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetAppointmentsEventImpl
    with DiagnosticableTreeMixin
    implements GetAppointmentsEvent {
  const _$GetAppointmentsEventImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MyAppointmentsEvent.getAppointments()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', 'MyAppointmentsEvent.getAppointments'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetAppointmentsEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAppointments,
    required TResult Function(
            Function onSuccess, bool value, int index, BuildContext context)
        updateDrugStatus,
    required TResult Function(SwitchModel switchData) getInitialData,
  }) {
    return getAppointments();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAppointments,
    TResult? Function(
            Function onSuccess, bool value, int index, BuildContext context)?
        updateDrugStatus,
    TResult? Function(SwitchModel switchData)? getInitialData,
  }) {
    return getAppointments?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAppointments,
    TResult Function(
            Function onSuccess, bool value, int index, BuildContext context)?
        updateDrugStatus,
    TResult Function(SwitchModel switchData)? getInitialData,
    required TResult orElse(),
  }) {
    if (getAppointments != null) {
      return getAppointments();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAppointmentsEvent value) getAppointments,
    required TResult Function(UpdateDrugStatus value) updateDrugStatus,
    required TResult Function(GetInitialData value) getInitialData,
  }) {
    return getAppointments(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAppointmentsEvent value)? getAppointments,
    TResult? Function(UpdateDrugStatus value)? updateDrugStatus,
    TResult? Function(GetInitialData value)? getInitialData,
  }) {
    return getAppointments?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAppointmentsEvent value)? getAppointments,
    TResult Function(UpdateDrugStatus value)? updateDrugStatus,
    TResult Function(GetInitialData value)? getInitialData,
    required TResult orElse(),
  }) {
    if (getAppointments != null) {
      return getAppointments(this);
    }
    return orElse();
  }
}

abstract class GetAppointmentsEvent implements MyAppointmentsEvent {
  const factory GetAppointmentsEvent() = _$GetAppointmentsEventImpl;
}

/// @nodoc
abstract class _$$UpdateDrugStatusImplCopyWith<$Res> {
  factory _$$UpdateDrugStatusImplCopyWith(_$UpdateDrugStatusImpl value,
          $Res Function(_$UpdateDrugStatusImpl) then) =
      __$$UpdateDrugStatusImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Function onSuccess, bool value, int index, BuildContext context});
}

/// @nodoc
class __$$UpdateDrugStatusImplCopyWithImpl<$Res>
    extends _$MyAppointmentsEventCopyWithImpl<$Res, _$UpdateDrugStatusImpl>
    implements _$$UpdateDrugStatusImplCopyWith<$Res> {
  __$$UpdateDrugStatusImplCopyWithImpl(_$UpdateDrugStatusImpl _value,
      $Res Function(_$UpdateDrugStatusImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? onSuccess = null,
    Object? value = null,
    Object? index = null,
    Object? context = null,
  }) {
    return _then(_$UpdateDrugStatusImpl(
      onSuccess: null == onSuccess
          ? _value.onSuccess
          : onSuccess // ignore: cast_nullable_to_non_nullable
              as Function,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      context: null == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$UpdateDrugStatusImpl
    with DiagnosticableTreeMixin
    implements UpdateDrugStatus {
  const _$UpdateDrugStatusImpl(
      {required this.onSuccess,
      required this.value,
      required this.index,
      required this.context});

  @override
  final Function onSuccess;
  @override
  final bool value;
  @override
  final int index;
  @override
  final BuildContext context;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MyAppointmentsEvent.updateDrugStatus(onSuccess: $onSuccess, value: $value, index: $index, context: $context)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MyAppointmentsEvent.updateDrugStatus'))
      ..add(DiagnosticsProperty('onSuccess', onSuccess))
      ..add(DiagnosticsProperty('value', value))
      ..add(DiagnosticsProperty('index', index))
      ..add(DiagnosticsProperty('context', context));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateDrugStatusImpl &&
            (identical(other.onSuccess, onSuccess) ||
                other.onSuccess == onSuccess) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.context, context) || other.context == context));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, onSuccess, value, index, context);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateDrugStatusImplCopyWith<_$UpdateDrugStatusImpl> get copyWith =>
      __$$UpdateDrugStatusImplCopyWithImpl<_$UpdateDrugStatusImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAppointments,
    required TResult Function(
            Function onSuccess, bool value, int index, BuildContext context)
        updateDrugStatus,
    required TResult Function(SwitchModel switchData) getInitialData,
  }) {
    return updateDrugStatus(onSuccess, value, index, context);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAppointments,
    TResult? Function(
            Function onSuccess, bool value, int index, BuildContext context)?
        updateDrugStatus,
    TResult? Function(SwitchModel switchData)? getInitialData,
  }) {
    return updateDrugStatus?.call(onSuccess, value, index, context);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAppointments,
    TResult Function(
            Function onSuccess, bool value, int index, BuildContext context)?
        updateDrugStatus,
    TResult Function(SwitchModel switchData)? getInitialData,
    required TResult orElse(),
  }) {
    if (updateDrugStatus != null) {
      return updateDrugStatus(onSuccess, value, index, context);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAppointmentsEvent value) getAppointments,
    required TResult Function(UpdateDrugStatus value) updateDrugStatus,
    required TResult Function(GetInitialData value) getInitialData,
  }) {
    return updateDrugStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAppointmentsEvent value)? getAppointments,
    TResult? Function(UpdateDrugStatus value)? updateDrugStatus,
    TResult? Function(GetInitialData value)? getInitialData,
  }) {
    return updateDrugStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAppointmentsEvent value)? getAppointments,
    TResult Function(UpdateDrugStatus value)? updateDrugStatus,
    TResult Function(GetInitialData value)? getInitialData,
    required TResult orElse(),
  }) {
    if (updateDrugStatus != null) {
      return updateDrugStatus(this);
    }
    return orElse();
  }
}

abstract class UpdateDrugStatus implements MyAppointmentsEvent {
  const factory UpdateDrugStatus(
      {required final Function onSuccess,
      required final bool value,
      required final int index,
      required final BuildContext context}) = _$UpdateDrugStatusImpl;

  Function get onSuccess;
  bool get value;
  int get index;
  BuildContext get context;
  @JsonKey(ignore: true)
  _$$UpdateDrugStatusImplCopyWith<_$UpdateDrugStatusImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetInitialDataImplCopyWith<$Res> {
  factory _$$GetInitialDataImplCopyWith(_$GetInitialDataImpl value,
          $Res Function(_$GetInitialDataImpl) then) =
      __$$GetInitialDataImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SwitchModel switchData});
}

/// @nodoc
class __$$GetInitialDataImplCopyWithImpl<$Res>
    extends _$MyAppointmentsEventCopyWithImpl<$Res, _$GetInitialDataImpl>
    implements _$$GetInitialDataImplCopyWith<$Res> {
  __$$GetInitialDataImplCopyWithImpl(
      _$GetInitialDataImpl _value, $Res Function(_$GetInitialDataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? switchData = null,
  }) {
    return _then(_$GetInitialDataImpl(
      switchData: null == switchData
          ? _value.switchData
          : switchData // ignore: cast_nullable_to_non_nullable
              as SwitchModel,
    ));
  }
}

/// @nodoc

class _$GetInitialDataImpl
    with DiagnosticableTreeMixin
    implements GetInitialData {
  const _$GetInitialDataImpl({required this.switchData});

  @override
  final SwitchModel switchData;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MyAppointmentsEvent.getInitialData(switchData: $switchData)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MyAppointmentsEvent.getInitialData'))
      ..add(DiagnosticsProperty('switchData', switchData));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetInitialDataImpl &&
            (identical(other.switchData, switchData) ||
                other.switchData == switchData));
  }

  @override
  int get hashCode => Object.hash(runtimeType, switchData);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetInitialDataImplCopyWith<_$GetInitialDataImpl> get copyWith =>
      __$$GetInitialDataImplCopyWithImpl<_$GetInitialDataImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAppointments,
    required TResult Function(
            Function onSuccess, bool value, int index, BuildContext context)
        updateDrugStatus,
    required TResult Function(SwitchModel switchData) getInitialData,
  }) {
    return getInitialData(switchData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAppointments,
    TResult? Function(
            Function onSuccess, bool value, int index, BuildContext context)?
        updateDrugStatus,
    TResult? Function(SwitchModel switchData)? getInitialData,
  }) {
    return getInitialData?.call(switchData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAppointments,
    TResult Function(
            Function onSuccess, bool value, int index, BuildContext context)?
        updateDrugStatus,
    TResult Function(SwitchModel switchData)? getInitialData,
    required TResult orElse(),
  }) {
    if (getInitialData != null) {
      return getInitialData(switchData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAppointmentsEvent value) getAppointments,
    required TResult Function(UpdateDrugStatus value) updateDrugStatus,
    required TResult Function(GetInitialData value) getInitialData,
  }) {
    return getInitialData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAppointmentsEvent value)? getAppointments,
    TResult? Function(UpdateDrugStatus value)? updateDrugStatus,
    TResult? Function(GetInitialData value)? getInitialData,
  }) {
    return getInitialData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAppointmentsEvent value)? getAppointments,
    TResult Function(UpdateDrugStatus value)? updateDrugStatus,
    TResult Function(GetInitialData value)? getInitialData,
    required TResult orElse(),
  }) {
    if (getInitialData != null) {
      return getInitialData(this);
    }
    return orElse();
  }
}

abstract class GetInitialData implements MyAppointmentsEvent {
  const factory GetInitialData({required final SwitchModel switchData}) =
      _$GetInitialDataImpl;

  SwitchModel get switchData;
  @JsonKey(ignore: true)
  _$$GetInitialDataImplCopyWith<_$GetInitialDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
